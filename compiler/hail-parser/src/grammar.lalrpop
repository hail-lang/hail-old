use crate::ast::*;

grammar;

// Useful macros
Node<T>: Node<T> = <start:@L> <node:T> <end:@R> => Node {
    loc: start..end,
    node,
};

Box<T>: Box<T> = <item:T> => Box::new(item);

List<T>: Vec<T> = <mut items:(<T> ",")*> <last:T?> => match last {
    Some(last) => {
        items.push(last);
        items
    },
    None => items,
};

// Declarations
pub Decls: Vec<Decl<'input>> = <decls:Decl*> => decls;

pub Decl: Decl<'input> = {
    <name:Node<Iden>> "::" <routine:Node<Routine>> => Decl::Routine(name, routine),
    <name:Node<Iden>> "::" <struct_:Node<Struct>> => Decl::Struct(name, struct_),
    <name:Node<Iden>> "::" <enum_:Node<Enum>> => Decl::Enum(name, enum_),
    <import:Import> => Decl::Import(import),
};

// TODO: add importing specific items, like:
// import { item } from module
// or
// import * as module from module
Import: Import<'input> = {
    "import" <module:Node<Iden>> => Import {
        kind: ImportKind::Module,
        module
    },
    "import" "{" <items:List<Node<AccessNode>>> "}" "from" <module:Node<Iden>> => Import {
        kind: ImportKind::Specific(items),
        module,
    },
    "import" "*" "as" <moduleas:Node<Iden>> "from" <module:Node<Iden>> => Import {
        kind: ImportKind::AllAs(moduleas),
        module,
    },
}

Enum: Enum<'input> = "enum" <generics:("<" <List<Node<TypeDecl>>> ">")?> "{" <props:List<Node<EnumMember>>> "}" => Enum {
    generics,
    props,
};

EnumMember: EnumMember<'input> = <name:Node<Iden>> <ty:("<-" <Node<TypeExpr>>)?> => EnumMember {
    name,
    ty,
};

Struct: Struct<'input> = "struct" <generics:("<" <List<Node<TypeDecl>>> ">")?> "{" <props:List<Node<StructProp>>> "}" => Struct {
    generics,
    props,
};

StructProp: StructProp<'input> = <name:Node<Iden>> "<-" <ty:Node<TypeExpr>> => StructProp {
    name,
    ty,
};

Routine: Routine<'input> =
    "routine" <generics:("<" <List<Node<TypeDecl>>> ">")?> "(" <args:List<Node<RoutineArg>>> ")" <returns:("->" <Node<TypeExpr>>)?>
        <block:("{" <Node<BlockExpr>*> "}")?> => Routine {
        generics,
        args,
        returns,
        block,
    };

RoutineArg: RoutineArg<'input> = <name:Node<Iden>> "<-" <ty:Node<TypeExpr>> => RoutineArg {
    name,
    ty,
};

// Type expressions
BlockExpr: BlockExpr<'input> = {
    <node:NodeOrNodes> => BlockExpr::Node(node),
    <val:Val> => BlockExpr::Val(val),
    <if_:If> => BlockExpr::If(if_),
    <while_:While> => BlockExpr::While(while_),
    <test:Test> => BlockExpr::Test(test),
};

Test: Test<'input> =
    "test" <subject:Node<NodeOrNodes>> <block:("{" <Node<TestArm>*> "}")> => Test {
        subject,
        block,
    };

TestArm: TestArm<'input> = {
    <name:Node<Iden>> <ty:("<-" <Node<TypeExpr>>)?> "=>" <action:Node<NodeOrNodes>> => TestArm {
        name,
        ty,
        action,
    },
};

While: While<'input> =
    "while" <cond:Node<NodeOrNodes>> <block:("{" <Node<BlockExpr>*> "}")> => While {
        cond,
        block,
    };

If: If<'input> =
    "if" <cond:Node<NodeOrNodes>> <block:("{" <Node<BlockExpr>*> "}")> <branches:Node<IfBranch>*> => If {
        cond,
        block,
        branches,
    };

IfBranch: IfBranch<'input> = {
    "else" "if" <cond:Node<NodeOrNodes>> <block:("{" <Node<BlockExpr>*> "}")> => IfBranch::ElseIf(cond, block),
    "else" <block:("{" <Node<BlockExpr>*> "}")> => IfBranch::Else(block),
};

Val: Val<'input> =
    "val" <name:Node<Iden>> <ty:("<-" <Node<TypeExpr>>)?> <value:("=" <Node<NodeOrNodes>>)?> => Val {
        name,
        ty,
        value,
    };

TypeDecl: TypeDecl<'input> =
    <name:Node<Iden>> <ty:("<-" <Node<TypeDeclExpr>>)?> => TypeDecl {
        name,
        ty,
    };

TypeDeclExpr: TypeDeclExpr<'input> = {
    <gen:TypeDeclGeneric> => gen,
    <left:Node<Box<TypeDeclExpr>>> "+" <right:Node<Box<TypeDeclGeneric>>> => TypeDeclExpr::And(left, right),
};

TypeDeclGeneric: TypeDeclExpr<'input> = {
    <name:AccessNode> => TypeDeclExpr::AccessNode(name),
    <subject:Node<Box<TypeDeclGeneric>>> "<" <generics:List<Node<TypeExpr>>> ">" => TypeDeclExpr::Generic(subject, generics),
};

TypeExpr: TypeExpr<'input> = {
    "fluid" <ty:Node<Box<TypeExpr>>> => TypeExpr::Fluid(ty),
    "&" <ty:Node<Box<TypeExpr>>> => TypeExpr::Ref(ty),
    "*" <ty:Node<Box<TypeExpr>>> => TypeExpr::Ptr(ty),
    <struct_:Node<Struct>> => TypeExpr::Struct(struct_),
    <enum_:Node<Enum>> => TypeExpr::Enum(enum_),
    <primary:PrimaryType> => primary,
}

PrimaryType: TypeExpr<'input> = {
    <access:AccessNode> => TypeExpr::AccessNode(access),
    <access:Node<AccessNode>> "<" <list:List<Node<TypeExpr>>> ">" => TypeExpr::Generic(access, list),
}

// Node patterns
pub NodeOrNodes: NodeOrNodes<'input> = {
    <node:InstNode> => NodeOrNodes::Node(node),
    "(" <nodes:Node<InstNode>*> ")" => NodeOrNodes::Nodes(nodes),
};

InstNode: InstNode<'input> = {
    <node:AccessExpr> => InstNode::AccessExpr(node),
    <node:Int> => InstNode::Int(node),
    <node:Float> => InstNode::Float(node),
    <node:Str> => InstNode::Str(node),
};

StructNodeProp: StructNodeProp<'input> =
    <name:Iden> <value:(":" <NodeOrNodes>)?> => StructNodeProp {
        name,
        value,
    };

AccessExpr: AccessExpr<'input> = {
    <iden:Iden> => AccessExpr::Iden(iden),
    <access:Node<Box<AccessExpr>>> "::" <iden:Iden> => AccessExpr::Static(access, iden),
    <access:Node<Box<AccessExpr>>> "::" "{" <props:List<Node<StructNodeProp>>> "}" => AccessExpr::Struct(access, props),
    <access:Node<Box<AccessExpr>>> "::" "<" <props:List<Node<TypeExpr>>> ">" => AccessExpr::Generic(access, props),
    <access:Node<Box<AccessExpr>>> "." <iden:Iden> => AccessExpr::Property(access, iden),
};

AccessNode: AccessNode<'input> = {
    <iden:Iden> => AccessNode::Iden(iden),
    <access:Node<Box<AccessNode>>> "::" <iden:Iden> => AccessNode::Static(access, iden),
};

Int: Int<'input> = <value:r"[0-9]"> => Int { value };
Float: Float<'input> = <value:r"[0-9]+\.[0-9]+([eE][-+]?[0-9]+)?"> => Float { value };
Iden: Iden<'input> = <value:r"[a-zA-Z_][a-zA-Z_0-9]*"> => Iden { value };
Str: Str<'input> = <value:r#""(?:[^"\\]|\\.)*""#> => Str { value };