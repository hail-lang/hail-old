// A Rust-like basic Vec implementation in Hail.
//
// The goal is to create a contract for a simple Vec type, and implement it.  In the future, a contract for Vec types will be included in the
// standard library Hail provides.

import { alloc, realloc, dealloc } from alloc
import { assert } from assert

// Contracts aren't types, so they use the `::` definition operator instead of the `<-` definition operator.

/// A dynamically sized array type.
Vec :: shared contract {
    /// The type of item that the Vec implements.
    Item <- type

    /// Returns the amount of items this Vec can hold without reallocating.
    size :: shared routine(self <- &Self) -> uint

    /// Returns the amount of items in this Vec.
    len :: shared routine(self <- &Self) -> uint

    /// Returns a fluid reference to the size of this Vec.
    /// 
    /// Used internally by the contract to set the size.
    size_fluid :: routine(self <- &fluid Self) -> &fluid uint

    /// Returns a fluid reference to the length of this Vec.
    /// 
    /// Used internally by the contract to set the size.
    len_fluid :: routine(self <- &fluid Self) -> &fluid uint

    /// Returns the pointer that this Vec wraps.
    /// 
    /// Used internally by the contract to set the size.
    ptr :: routine(self <- &Self) -> &fluid Self::Item

    /// Sets the size of this Vec.
    grow :: routine(self <- &fluid Self) {
        val new_size = Self::size(self) * 2
        *Self::size_fluid(self) = new_size
        realloc(Self::ptr(self), new_size * Self::Item::type_size())
    }

    /// Pushes an item to the end of this Vec.
    /// 
    /// Automatically reallocates the Vec's memory if required.
    push :: shared routine(self <- &fluid Self, item <- Self::Item) {
        if Self::len(self) >= Self::size(self) {
            Self::grow(self)
        }

        (Self::ptr(self) + Self::len(self)) = item
        *Self::len_fluid(self) = Self::len(self) + 1
    }

    /// Pops an item from the array and returns it.
    pop :: shared routine(self <- &fluid Self, item <- Self::Item) -> Self::Item {
        val item = Self::ptr(self) + Self::len(self) // <- &fluid Self::Item
        return *item
    }

    /// Gets an item in this Vec, at the provided index.
    get :: shared routine(self <- &Self, idx <- uint) -> ?&Self::Item {
        if idx >= Self::len(self) {
            return none
        }

        return some((Self::ptr(self) + idx) as &Self::Item)
    }

    /// Gets a fluid reference to an item in this Vec.
    get_fluid :: shared routine(self <- &fluid Self, idx <- uint) -> ?&fluid Self::Item {
        if idx >= Self::len(self) {
            return none
        }

        return some((Self::ptr(self) + idx))
    }
}

/// A Vec of `uint`s.
UintVec :: struct {
    /// The memory block that this Vec wraps.
    ptr <- &fluid uint,

    /// The amount of items stored in this Vec.
    len <- uint,

    /// The amount of items that this Vec can hold.
    size <- uint,
}

apply UintVec {
    /// Creates a new, empty UintVec.
    new :: shared routine() -> Self {
        return Self::{
            ptr <- alloc(uint::type_size()),
            len <- 0,
            size <- 1,
        }
    }
}

apply Vec to UintVec {
    Item <- uint

    size :: shared routine(self <- &Self) -> uint {
        return *self.size
    }

    len :: shared routine(self <- &Self) -> uint {
        return *self.len
    }

    size_fluid :: shared routine(self <- &fluid Self) -> &fluid uint {
        return self.size
    }

    len_fluid :: shared routine(self <- &fluid Self) -> &fluid uint {
        return self.len
    }

    ptr :: shared routine(self <- &Self) -> &fluid Self::Item {
        return *self.ptr
    }
}

apply Drop to UintVec {
    drop :: shared routine(self <- Self) {
        dealloc(self.ptr)
    }
}

main :: routine() {
    val fluid vec = UintVec::new()
    UintVec::push(&fluid vec, 42)

    assert(UintVec::len(&vec) == 1)

    assert(UintVec::pop(&fluid vec) == some(42))
    assert(UintVec::len(&vec) == 0)
}